#### 知识点学习

bitcask

[Bitcask 存储模型 - 如果的事 - 博客园 (cnblogs.com)](https://www.cnblogs.com/chenny7/p/4572381.html)

wal

通过将每个状态更改作为命令添加到append only 日志中，从而提供持久性保证，而无需将数据结构刷新到磁盘

一次成功的操作对应：写入内存+wal，突发情况，可以根据wal恢复

#### 设计

**执行命令**：

1.append到日志

2.加入内存hashmap

**启动**：

根据日志进行恢复

**定时、启动：**

对log记录进行压缩，只保留，最新的操作，压缩中将数据写入到新的文件，

##### rust线程间通信，

channel response：通过传递一个rxchannel

#### 实现步骤

1. x 先完成了初始化时的指令重做 以及 创建线程以及通道读取来自用户的命令 以及对应的存储操作

   暂时是将k 和v 都存在map中

2. x 用户循环读取指令，并通过通道向存储线程发送命令

3. x 将内存中的kv映射从值改为存储索引

4. x 实现 Periodically compact the log to remove stale data

   1. 大小到阈值后，新建一个文件用于压缩，一个文件用于存储（先获取当前文件列表，选取列表中不存在的数字
   2. 在压缩过程中，依然允许外部访问读取，同时，外部访问写入会写入到新的存储文件中
   3. 压缩过程：遍历以及获取到的文件列表，可能为之前的压缩，也可能为刚满了的文件，越早编辑的文件先访问，将k对应一个位置信息，存入map，这样新的同一个k的操作覆盖旧的，
   4. 在压缩完毕后，更新所有hash中的索引到新文件，
   5. 删除旧文件，

5. 初始化时能回选目标写入文件，增加一个文件来记录当前写入的目标

#### 测试有效性

